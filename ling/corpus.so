load "map.so";
load "string.so";

struct Corpus class {
	var corpus;
	var TFcache;
	var IDFcache;

	init() => {
		corpus = {};
		TFcache = new Map();
		IDFcache = new Map();
	}

	resetCache() => {
		TFcache = new Map();
		IDFcache = new Map();
	}

	add(value) => {
		type(value) != "Vector" then {
			value = value.split("\\s");
		}
		corpus += {value};
		resetCache();
	}

	TF(final value, final doc) => {
		TFcache.contains({value, doc}) then {
			return TFcache[{value, doc}];
		}
		var c = 0;
		doc == null then {
			i in corpus do {
				j in i do {
					j == value then {
						c += 1;
					}
				}
			}
		} else {
			j in corpus[doc] do {
				j == value then {
					c += 1;
				}
			}
		}
		return c;
	}

	count(ref value) => {
		var c = 0;
		i in corpus do {
			j in i do {
				j == value then {
					c += 1;
					break;
				}
			}
		}
		return c;
	}

	IDF(ref value) => {
		IDFcache.contains(value) then {
			return IDFcache[value];
		}
		return 1 + (length(corpus) / (1 + count(value))).log();
	}

	TFIDF(final value, final doc) => {
		var array = value;
		type(value) != "Vector" then {
			array = { value };
		}
		var freq = 0;
		v in array do {
			freq += TF(v, doc) * IDF(v);
		}
		return freq;
	}

	getList() => {
		return corpus;
	}

	getLength() => {
		return length(corpus);
	}
}